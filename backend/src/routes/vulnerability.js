module.exports = function(app) {

    var Response = require('../lib/httpResponse.js');
    var acl = require('../lib/auth').acl;
    var Vulnerability = require('mongoose').model('Vulnerability');
    var VulnerabilityType = require('mongoose').model('VulnerabilityType');
    var VulnerabilityCategory = require('mongoose').model('VulnerabilityCategory');
    var VulnerabilityUpdate = require('mongoose').model('VulnerabilityUpdate');
    var Settings = require('mongoose').model('Settings');
    var OpenAI = require('openai');
    var axios = require('axios');

    // Helper function to validate if a URL exists
    async function validateUrl(url) {
        try {
            // First try HEAD request (faster)
            const response = await axios.head(url, {
                timeout: 5000,
                maxRedirects: 3,
                validateStatus: (status) => status < 400,
                headers: {
                    'User-Agent': 'Mozilla/5.0 (compatible; PwndocAI/1.0)'
                }
            });
            return true;
        } catch (headError) {
            // Some servers don't support HEAD, try GET
            try {
                const response = await axios.get(url, {
                    timeout: 5000,
                    maxRedirects: 3,
                    validateStatus: (status) => status < 400,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (compatible; PwndocAI/1.0)'
                    }
                });
                return true;
            } catch (getError) {
                return false;
            }
        }
    }

    // Helper function to get OWASP fallback links based on vulnerability keywords
    function getOwaspFallbackLinks(title, description) {
        const text = (title + ' ' + description).toLowerCase();
        const fallbackLinks = [];

        // Map keywords to OWASP Top 10 2021 links
        const owaspMappings = [
            { keywords: ['sql injection', 'sqli', 'sql injeção'], url: 'https://owasp.org/Top10/A03_2021-Injection/' },
            { keywords: ['xss', 'cross-site scripting', 'cross site scripting'], url: 'https://owasp.org/Top10/A03_2021-Injection/' },
            { keywords: ['command injection', 'os injection', 'rce', 'remote code execution'], url: 'https://owasp.org/Top10/A03_2021-Injection/' },
            { keywords: ['ldap injection'], url: 'https://owasp.org/Top10/A03_2021-Injection/' },
            { keywords: ['xpath injection'], url: 'https://owasp.org/Top10/A03_2021-Injection/' },
            { keywords: ['authentication', 'autenticação', 'login', 'password', 'senha', 'credential', 'session', 'sessão'], url: 'https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/' },
            { keywords: ['access control', 'authorization', 'autorização', 'privilege', 'idor', 'insecure direct object'], url: 'https://owasp.org/Top10/A01_2021-Broken_Access_Control/' },
            { keywords: ['cryptograph', 'criptograf', 'encryption', 'criptografia', 'ssl', 'tls', 'certificate', 'certificado', 'hash'], url: 'https://owasp.org/Top10/A02_2021-Cryptographic_Failures/' },
            { keywords: ['misconfiguration', 'configuração', 'default', 'hardening'], url: 'https://owasp.org/Top10/A05_2021-Security_Misconfiguration/' },
            { keywords: ['ssrf', 'server-side request', 'server side request'], url: 'https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/' },
            { keywords: ['deserialization', 'deserialização', 'insecure deserial'], url: 'https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/' },
            { keywords: ['xxe', 'xml external', 'xml injection'], url: 'https://owasp.org/Top10/A05_2021-Security_Misconfiguration/' },
            { keywords: ['csrf', 'cross-site request forgery', 'cross site request forgery'], url: 'https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html' },
            { keywords: ['file upload', 'upload de arquivo', 'unrestricted upload'], url: 'https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload' },
            { keywords: ['path traversal', 'directory traversal', 'lfi', 'local file inclusion'], url: 'https://owasp.org/www-community/attacks/Path_Traversal' },
            { keywords: ['open redirect', 'redirecionamento aberto'], url: 'https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html' },
            { keywords: ['clickjacking', 'ui redressing'], url: 'https://owasp.org/www-community/attacks/Clickjacking' },
            { keywords: ['cors', 'cross-origin'], url: 'https://owasp.org/www-community/attacks/CORS_OriginHeaderScrutiny' },
            { keywords: ['header injection', 'http response splitting'], url: 'https://owasp.org/www-community/attacks/HTTP_Response_Splitting' },
            { keywords: ['information disclosure', 'divulgação de informação', 'sensitive data', 'dados sensíveis'], url: 'https://owasp.org/Top10/A02_2021-Cryptographic_Failures/' }
        ];

        for (const mapping of owaspMappings) {
            if (mapping.keywords.some(keyword => text.includes(keyword))) {
                if (!fallbackLinks.includes(mapping.url)) {
                    fallbackLinks.push(mapping.url);
                }
            }
        }

        // Always add the Web Security Testing Guide as a general reference if no specific matches
        if (fallbackLinks.length === 0) {
            fallbackLinks.push('https://owasp.org/www-project-web-security-testing-guide/');
        }

        return fallbackLinks;
    }

    // Get vulnerabilities list
    app.get("/api/vulnerabilities", acl.hasPermission('vulnerabilities:read'), function(req, res) {
        Vulnerability.getAll()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerabilities for export
    //app.get("/api/vulnerabilities/export", acl.hasPermission('vulnerabilities:read'), function(req, res) {
    app.get("/api/vulnerabilities/export", acl.hasPermission('vulnerabilities:export'), function(req, res) {
        Vulnerability.export()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Create vulnerabilities (array of vulnerabilities)
    app.post("/api/vulnerabilities", acl.hasPermission('vulnerabilities:create'), function(req, res) {
        for (var i=0; i< req.body.length;i++) {
            var vuln = req.body[i]
            if (!vuln.details) {
                Response.BadParameters(res, 'Required parameters: details.locale, details.title');
                return;
            }
            var index = vuln.details.findIndex(obj => (obj.locale && obj.locale !== '' && obj.title && obj.title !== ''));
            if (index < 0) {
                Response.BadParameters(res, 'Required parameters: details.locale, details.title');
                return;
            }
        };

        var vulnerabilities = [];
        for (var i=0; i<req.body.length; i++) {
            var vuln = {}
            vuln.cvssv3 = req.body[i].cvssv3 || null;
            vuln.cvssv4 = req.body[i].cvssv4 || null;
            if (req.body[i].priority) vuln.priority = req.body[i].priority;
            if (req.body[i].remediationComplexity) vuln.remediationComplexity = req.body[i].remediationComplexity;
            if (req.body[i].category) {
                vuln.category = req.body[i].category;
                VulnerabilityCategory.create({name: vuln.category}).catch(e => {})
            }
            vuln.details = [];
            req.body[i].details.forEach(d => {
                if (!d.title || !d.locale) // Array of details may contain entries without title or locale but we don't want to save them
                    return
                var details = {};
                if (d.locale) details.locale = d.locale;
                if (d.title) details.title = d.title;
                if (d.vulnType) {
                    details.vulnType = d.vulnType;
                    VulnerabilityType.create({locale: d.locale, name: d.vulnType})
                    .catch(e => {})
                }
                if (d.description) details.description = d.description;
                if (d.observation) details.observation = d.observation;
                if (d.remediation) details.remediation = d.remediation;
                if (d.references) details.references = d.references;
                if (d.customFields) details.customFields = d.customFields
                vuln.details.push(details);
            })
            vuln.status = 0;
            vulnerabilities.push(vuln);
        }
        Vulnerability.create(vulnerabilities)
        .then(msg => Response.Created(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Generate vulnerability content using AI
    app.post("/api/vulnerabilities/ai-generate", acl.hasPermission('vulnerabilities:create'), async function(req, res) {
        //console.log('[DEBUG] AI Generate endpoint hit');
        //console.log('[DEBUG] Request body:', JSON.stringify(req.body, null, 2));
        
        // Validate required parameters - need at least title or description
        const title = req.body.title ? req.body.title.trim() : '';
        const description = req.body.description ? req.body.description.trim() : '';
        
        //console.log('[DEBUG] Parsed title:', title);
        //console.log('[DEBUG] Parsed description:', description);
        
        if (!title && !description) {
            //console.log('[DEBUG] Validation failed: no title or description');
            Response.BadParameters(res, 'Required parameters: title or description');
            return;
        }

        // Set default locale if not provided
        const locale = req.body.locale || 'en';
        //console.log('[DEBUG] Using locale:', locale);

        try {
            //console.log('[DEBUG] Getting AI settings...');
            // Get AI settings from database (internal method with actual API key)
            const aiSettings = await Settings.getOpenAIApiKey();
            /*console.log('[DEBUG] AI settings retrieved:', {
                enabled: aiSettings.enabled,
                model: aiSettings.model,
                hasApiKey: !!(aiSettings.apiKey && aiSettings.apiKey.trim() !== '')
            }); */
            
            // Check if AI is enabled
            if (!aiSettings.enabled) {
                //console.log('[DEBUG] AI features not enabled');
                Response.BadParameters(res, 'AI features are not enabled');
                return;
            }

            // Check if OpenAI API key is configured
            if (!aiSettings.apiKey || aiSettings.apiKey.trim() === '') {
                //console.log('[DEBUG] OpenAI API key not configured');
                Response.BadParameters(res, 'OpenAI API key is not configured');
                return;
            }

            // Get the model to use
            const model = aiSettings.model;

            // Initialize OpenAI client
            const openai = new OpenAI({
                apiKey: aiSettings.apiKey,
            });

            // Language mapping for AI prompt
            const languageMap = {
                'en': 'English',
                'en_US': 'English',
                'pt_BR': 'Brazilian Portuguese',
                'pt': 'Portuguese',
                'es': 'Spanish',
            };

            // Get the language name for the prompt
            const targetLanguage = languageMap[locale] || 'English';
            const languageInstruction = targetLanguage !== 'English' 
                ? `Generate all vulnerability content (description, observation, remediation) in ${targetLanguage}. Use appropriate ${targetLanguage} terminology and expressions. Do not translate technical terms like CVSS vectors, but ensure all descriptive text is in ${targetLanguage}.\n\n`
                : '';

            // Construct the prompt
            const prompt = `You are a cybersecurity expert. Based on the vulnerability title and description provided, generate detailed vulnerability information in JSON format that is appropriate for a professional penetration test report.

${languageInstruction}
Title: ${title}
Description: ${description}

Generate a JSON response with these exact fields:
{
  "description": "detailed technical description using <p> tags for paragraphs. Use cwe style langue. ",
  "observation": "specific observations about the vulnerability using <p> tags", 
  "remediation": "step-by-step remediation instructions using <p> tags",
  "references": ["reference1", "reference2", "reference3"],
  "cvssv3": "",
  "cvssScore": 0.0,
  "remediationComplexity": 1,
  "priority": 1
}

Requirements:
- Use <p></p> tags for paragraphs, never <br> tags
- Use CWE and OWASP style language for descriptions, observations, and remediation.
- Description should be detailed and technical. It should not be a simple summary.
- Description should not include details about the current finding, only a description of the vulnerability type.
- Description should include potential impacts and risks associated with the vulnerability.
- Description should be at least two paragraphs long.
- Observation should include specific details about the vulnerability that was identified.
- Remediation information should be practical and actionable. Where relevant, include code examples or configuration changes.
- Remediation should always contain step-by-step instructions.
- Remediation should always contain a disclaimer that the remediation should be tested in a staging environment before applying to production.
- References should be relevant and authoritative URLs that are known to exist.
- For web application vulnerabilities, ALWAYS prioritize OWASP.org links (e.g., https://owasp.org/Top10/, https://cheatsheetseries.owasp.org/, https://owasp.org/www-community/).
- Include CWE links from cwe.mitre.org when applicable (e.g., https://cwe.mitre.org/data/definitions/79.html for XSS).
- Provide 3-5 relevant reference URLs. Only suggest URLs that are well-known and likely to exist.
- Generate a realistic and unique CVSS v3.1 vector string based on the specific vulnerability type and context
- Calculate the appropriate CVSS score as a decimal (0.0-10.0) based on the vector
- Set remediationComplexity: 1=Easy, 2=Medium, 3=Complex
- Set priority: 1=Low, 2=Medium, 3=High, 4=Urgent
- Keep content practical and actionable for penetration testing reports
- Ensure valid JSON format
- Return only the JSON object, no additional text

CVSS Vector Guidelines - Analyze the specific vulnerability to determine appropriate values:
- Attack Vector (AV): N=Network, A=Adjacent, L=Local, P=Physical
- Attack Complexity (AC): L=Low, H=High
- Privileges Required (PR): N=None, L=Low, H=High
- User Interaction (UI): N=None, R=Required
- Scope (S): U=Unchanged, C=Changed
- Confidentiality Impact (C): N=None, L=Low, H=High
- Integrity Impact (I): N=None, L=Low, H=High
- Availability Impact (A): N=None, L=Low, H=High

Important: Each vulnerability should have its own unique CVSS vector and score based on its specific characteristics. Do not use generic or template values.`;

            // Call OpenAI API
            const completion = await openai.chat.completions.create({
                model: model,
                messages: [
                    {
                        role: "system",
                        content: "You are a cybersecurity expert that is writing vulnerabilities for a penetration test report. You generate vulnerability information in JSON format."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                max_tokens: 1500,
                temperature: 0.7,
            });

            // Parse the response
            const aiResponse = completion.choices[0].message.content.trim();
            
            // Try to parse JSON response
            let generatedContent;
            try {
                generatedContent = JSON.parse(aiResponse);
            } catch (parseError) {
                // If JSON parsing fails, try to extract JSON from the response
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    generatedContent = JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error('Invalid JSON response from AI');
                }
            }

            // Validate required fields
            if (!generatedContent.description || !generatedContent.observation || 
                !generatedContent.remediation || !generatedContent.references) {
                throw new Error('AI response missing required fields');
            }

            // Ensure references is an array
            if (!Array.isArray(generatedContent.references)) {
                generatedContent.references = [];
            }

            // Validate reference URLs and add OWASP fallbacks if needed
            let validatedReferences = [];

            // Filter to only URL-like strings
            const urlReferences = generatedContent.references.filter(ref =>
                typeof ref === 'string' && (ref.startsWith('http://') || ref.startsWith('https://'))
            );

            // Validate each URL in parallel
            if (urlReferences.length > 0) {
                const validationResults = await Promise.all(
                    urlReferences.map(async (url) => {
                        const isValid = await validateUrl(url);
                        return { url, isValid };
                    })
                );

                // Keep only valid URLs
                validatedReferences = validationResults
                    .filter(result => result.isValid)
                    .map(result => result.url);
            }

            // If we have fewer than 2 valid references, add OWASP fallback links
            if (validatedReferences.length < 2) {
                const fallbackLinks = getOwaspFallbackLinks(title, description);

                // Add fallback links that aren't already in the list
                for (const link of fallbackLinks) {
                    if (!validatedReferences.includes(link) && validatedReferences.length < 5) {
                        validatedReferences.push(link);
                    }
                }
            }

            // Deduplicate and limit to 5 references
            generatedContent.references = [...new Set(validatedReferences)].slice(0, 5);

            // Validate and sanitize CVSS and complexity fields
            let cvssv3 = null;
            let cvssScore = null;
            let remediationComplexity = null;
            let priority = null;

            // Validate CVSS v3 vector string
            if (generatedContent.cvssv3 && typeof generatedContent.cvssv3 === 'string') {
                const cvssPattern = /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]$/;
                if (cvssPattern.test(generatedContent.cvssv3)) {
                    cvssv3 = generatedContent.cvssv3;
                }
            }

            // Validate CVSS score
            if (generatedContent.cvssScore && typeof generatedContent.cvssScore === 'number') {
                if (generatedContent.cvssScore >= 0.0 && generatedContent.cvssScore <= 10.0) {
                    cvssScore = Math.round(generatedContent.cvssScore * 10) / 10; // Round to 1 decimal place
                }
            }

            // Validate remediation complexity (1-3)
            if (generatedContent.remediationComplexity && typeof generatedContent.remediationComplexity === 'number') {
                if (generatedContent.remediationComplexity >= 1 && generatedContent.remediationComplexity <= 3) {
                    remediationComplexity = Math.floor(generatedContent.remediationComplexity);
                }
            }

            // Validate priority (1-4)
            if (generatedContent.priority && typeof generatedContent.priority === 'number') {
                if (generatedContent.priority >= 1 && generatedContent.priority <= 4) {
                    priority = Math.floor(generatedContent.priority);
                }
            }

            // Return the generated content for user review
            const responseData = {
                title: title,
                locale: locale,
                description: generatedContent.description,
                observation: generatedContent.observation,
                remediation: generatedContent.remediation,
                references: generatedContent.references,
                cvssv3: cvssv3,
                cvssScore: cvssScore,
                remediationComplexity: remediationComplexity,
                priority: priority
            };

            Response.Ok(res, responseData);

        } catch (error) {
            console.error('OpenAI API Error:', error);
            
            // Handle specific error types
            if (error.code === 'insufficient_quota') {
                Response.BadParameters(res, 'OpenAI API quota exceeded. Please try again later.');
            } else if (error.code === 'rate_limit_exceeded') {
                Response.BadParameters(res, 'OpenAI API rate limit exceeded. Please try again later.');
            } else if (error.message && error.message.includes('API key')) {
                Response.BadParameters(res, 'Invalid OpenAI API key configuration.');
            } else if (error.message && error.message.includes('JSON')) {
                Response.BadParameters(res, 'Failed to parse AI response. Please try again.');
            } else {
                Response.BadParameters(res, 'OpenAI API is currently unavailable. Please try again later.');
            }
        }
    });

    // Update vulnerability
    app.put("/api/vulnerabilities/:vulnerabilityId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        if (!req.body.details) {
            Response.BadParameters(res, 'Required parameters: details.locale, details.title');
            return;
        }
        var index = req.body.details.findIndex(obj => (obj.locale && obj.locale !== '' && obj.title && obj.title !== ''));
        if (index < 0) {
            Response.BadParameters(res, 'Required parameters: details.locale, details.title');
            return;
        }

        var vuln = {}
        if (req.body.cvssv3) vuln.cvssv3 = req.body.cvssv3;
        if (req.body.cvssv4) vuln.cvssv4 = req.body.cvssv4;
        if (req.body.priority) vuln.priority = req.body.priority;
        if (req.body.remediationComplexity) vuln.remediationComplexity = req.body.remediationComplexity;
        vuln.category = req.body.category || null;
        vuln.details = [];
        req.body.details.forEach(d => {
            if (!d.title || !d.locale)
                return
            var details = {};
            if (d.locale) details.locale = d.locale;
            if (d.title) details.title = d.title;
            if (d.vulnType) details.vulnType = d.vulnType;
            if (d.description) details.description = d.description;
            if (d.observation) details.observation = d.observation;
            if (d.remediation) details.remediation = d.remediation;
            if (d.references) details.references = d.references;
            if (d.customFields) details.customFields = d.customFields
            vuln.details.push(details);
        })
        vuln.status = 0;
        
        Vulnerability.update(req.params.vulnerabilityId, vuln)
        .then(msg => {
            if (req.body.status === 2)
                VulnerabilityUpdate.deleteAllByVuln(req.params.vulnerabilityId)
            Response.Ok(res, msg)
        })
        .catch(err => Response.Internal(res, err))
    });

    // Delete vulnerability
    app.delete("/api/vulnerabilities/:vulnerabilityId", acl.hasPermission('vulnerabilities:delete'), function(req, res) {
        Vulnerability.delete(req.params.vulnerabilityId)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Delete all vulnerabilities
    app.delete("/api/vulnerabilities", acl.hasPermission('vulnerabilities:delete-all'), function(req, res) {
        Vulnerability.deleteAll()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerabilities list by language
    app.get("/api/vulnerabilities/:locale", acl.hasPermission('vulnerabilities:read'), function(req, res) {
        Vulnerability.getAllByLanguage(req.params.locale)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Create or Update vulnerability from finding for validation
    app.post("/api/vulnerabilities/finding/:locale", acl.hasPermission('vulnerability-updates:create'), function(req, res) {
        if (!req.body.title) {
            Response.BadParameters(res, 'Required parameters: title');
            return;
        }
        
        var vuln = {}
        // Required params
        vuln.title = req.body.title;
        vuln.locale = req.params.locale;

        // Optional params
        vuln.cvssv3 = req.body.cvssv3 || null;
        vuln.cvssv4 = req.body.cvssv4 || null;
        vuln.priority = req.body.priority || null;
        vuln.remediationComplexity = req.body.remediationComplexity || null;
        vuln.references = req.body.references || [];
        vuln.vulnType = req.body.vulnType || null;
        vuln.description = req.body.description || null;
        vuln.observation = req.body.observation || null;
        vuln.remediation = req.body.remediation || null;
        vuln.category = req.body.category || null;
        vuln.customFields = req.body.customFields || [];

        VulnerabilityUpdate.create(req.decodedToken.username, vuln)
        .then(msg => {
            if (msg === "Finding created as new Vulnerability")
                Response.Created(res, msg)
            else
                Response.Ok(res, msg)
        })
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerability updates form vuln id
    app.get("/api/vulnerabilities/updates/:vulnId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        VulnerabilityUpdate.getAllByVuln(req.params.vulnId)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Merge vulnerability with locale part of another one
    app.put("/api/vulnerabilities/merge/:vulnId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        if (!req.body.vulnId || !req.body.locale) {
            Response.BadParameters(res, 'Required parameters: vulnId, locale');
            return;
        }

        Vulnerability.Merge(req.params.vulnId, req.body.vulnId, req.body.locale)
        .then(() => Response.Ok(res, 'Vulnerability merge successfully'))
        .catch(err => Response.Internal(res, err))
    });
}
