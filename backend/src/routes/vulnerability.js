module.exports = function(app) {

    var Response = require('../lib/httpResponse.js');
    var acl = require('../lib/auth').acl;
    var Vulnerability = require('mongoose').model('Vulnerability');
    var VulnerabilityType = require('mongoose').model('VulnerabilityType');
    var VulnerabilityCategory = require('mongoose').model('VulnerabilityCategory');
    var VulnerabilityUpdate = require('mongoose').model('VulnerabilityUpdate');
    var Settings = require('mongoose').model('Settings');
    var OpenAI = require('openai');

    // Get vulnerabilities list
    app.get("/api/vulnerabilities", acl.hasPermission('vulnerabilities:read'), function(req, res) {
        Vulnerability.getAll()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerabilities for export
    //app.get("/api/vulnerabilities/export", acl.hasPermission('vulnerabilities:read'), function(req, res) {
    app.get("/api/vulnerabilities/export", acl.hasPermission('vulnerabilities:export'), function(req, res) {
        Vulnerability.export()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Create vulnerabilities (array of vulnerabilities)
    app.post("/api/vulnerabilities", acl.hasPermission('vulnerabilities:create'), function(req, res) {
        for (var i=0; i< req.body.length;i++) {
            var vuln = req.body[i]
            if (!vuln.details) {
                Response.BadParameters(res, 'Required parameters: details.locale, details.title');
                return;
            }
            var index = vuln.details.findIndex(obj => (obj.locale && obj.locale !== '' && obj.title && obj.title !== ''));
            if (index < 0) {
                Response.BadParameters(res, 'Required parameters: details.locale, details.title');
                return;
            }
        };

        var vulnerabilities = [];
        for (var i=0; i<req.body.length; i++) {
            var vuln = {}
            vuln.cvssv3 = req.body[i].cvssv3 || null;
            vuln.cvssv4 = req.body[i].cvssv4 || null;
            if (req.body[i].priority) vuln.priority = req.body[i].priority;
            if (req.body[i].remediationComplexity) vuln.remediationComplexity = req.body[i].remediationComplexity;
            if (req.body[i].category) {
                vuln.category = req.body[i].category;
                VulnerabilityCategory.create({name: vuln.category}).catch(e => {})
            }
            vuln.details = [];
            req.body[i].details.forEach(d => {
                if (!d.title || !d.locale) // Array of details may contain entries without title or locale but we don't want to save them
                    return
                var details = {};
                if (d.locale) details.locale = d.locale;
                if (d.title) details.title = d.title;
                if (d.vulnType) {
                    details.vulnType = d.vulnType;
                    VulnerabilityType.create({locale: d.locale, name: d.vulnType})
                    .catch(e => {})
                }
                if (d.description) details.description = d.description;
                if (d.observation) details.observation = d.observation;
                if (d.remediation) details.remediation = d.remediation;
                if (d.references) details.references = d.references;
                if (d.customFields) details.customFields = d.customFields
                vuln.details.push(details);
            })
            vuln.status = 0;
            vulnerabilities.push(vuln);
        }
        Vulnerability.create(vulnerabilities)
        .then(msg => Response.Created(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Generate vulnerability content using AI
    app.post("/api/vulnerabilities/ai-generate", acl.hasPermission('vulnerabilities:create'), async function(req, res) {
        // Validate required parameters
        if (!req.body.title || req.body.title.trim() === '') {
            Response.BadParameters(res, 'Required parameters: title');
            return;
        }

        // Set default locale if not provided
        const locale = req.body.locale || 'en';
        const title = req.body.title.trim();
        const description = req.body.description ? req.body.description.trim() : '';

        try {
            // Get AI settings from database (internal method with actual API key)
            const aiSettings = await Settings.getOpenAIApiKey();
            
            // Check if AI is enabled
            if (!aiSettings.enabled) {
                Response.BadParameters(res, 'AI features are not enabled');
                return;
            }

            // Check if OpenAI API key is configured
            if (!aiSettings.apiKey || aiSettings.apiKey.trim() === '') {
                Response.BadParameters(res, 'OpenAI API key is not configured');
                return;
            }

            // Get the model to use
            const model = aiSettings.model;

            // Initialize OpenAI client
            const openai = new OpenAI({
                apiKey: aiSettings.apiKey,
            });

            // Construct the prompt
            const prompt = `You are a cybersecurity expert. Based on the vulnerability title and description provided, generate detailed vulnerability information in JSON format that is appropriate for a professional penetration test report.

Title: ${title}
Description: ${description}

Generate a JSON response with these exact fields:
{
  "description": "detailed technical description using <p> tags for paragraphs. Use cwe style langue. ",
  "observation": "specific observations about the vulnerability using <p> tags", 
  "remediation": "step-by-step remediation instructions using <p> tags",
  "references": ["reference1", "reference2", "reference3"],
  "cvssv3": "CVSS:3.1/AV:X/AC:X/PR:X/UI:X/S:X/C:X/I:X/A:X",
  "cvssScore": 0.0,
  "remediationComplexity": 1,
  "priority": 1
}

Requirements:
- Use <p></p> tags for paragraphs, never <br> tags
- Use CWE and OWASP style language for descriptions, observations, and remediation.
- Description should be detailed and technical. It should not be a simple summary.
- Description should not include details about the current finding, only a description of the vulnerability type.
- Description should include potential impacts and risks associated with the vulnerability.
- Description should be at least two paragraphs long.
- Observation should include specific details about the vulnerability that was identified.
- Remediation information should be practical and actionable. Where relevant, include code examples or configuration changes.
- Remediation should always contain step-by-step instructions.
- Remediation should always contain a disclaimer that the remediation should be tested in a staging environment before applying to production.
- References should be relevant and authoritative, such as CVE numbers, OWASP pages, or security standards.
- Provide 3-5 relevant references (URLs, CVE numbers, standards)
- Generate a realistic CVSS v3.1 vector string based on the vulnerability type
- Calculate the CVSS score as a decimal (0.0-10.0)
- Set remediationComplexity: 1=Easy, 2=Medium, 3=Complex
- Set priority: 1=Low, 2=Medium, 3=High, 4=Urgent
- Keep content practical and actionable for penetration testing reports
- Ensure valid JSON format
- Return only the JSON object, no additional text

CVSS Vector Guidelines:
- Attack Vector (AV): N=Network, A=Adjacent, L=Local, P=Physical
- Attack Complexity (AC): L=Low, H=High
- Privileges Required (PR): N=None, L=Low, H=High
- User Interaction (UI): N=None, R=Required
- Scope (S): U=Unchanged, C=Changed
- Confidentiality Impact (C): N=None, L=Low, H=High
- Integrity Impact (I): N=None, L=Low, H=High
- Availability Impact (A): N=None, L=Low, H=High

Examples:
- SQL Injection: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H (Score: 9.8)
- XSS: CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N (Score: 6.1)
- Local Privilege Escalation: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H (Score: 7.8)`;

            // Call OpenAI API
            const completion = await openai.chat.completions.create({
                model: model,
                messages: [
                    {
                        role: "system",
                        content: "You are a cybersecurity expert that is writing vulnerabilities for a penetration test report. You generate vulnerability information in JSON format."
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                max_tokens: 1500,
                temperature: 0.7,
            });

            // Parse the response
            const aiResponse = completion.choices[0].message.content.trim();
            
            // Try to parse JSON response
            let generatedContent;
            try {
                generatedContent = JSON.parse(aiResponse);
            } catch (parseError) {
                // If JSON parsing fails, try to extract JSON from the response
                const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    generatedContent = JSON.parse(jsonMatch[0]);
                } else {
                    throw new Error('Invalid JSON response from AI');
                }
            }

            // Validate required fields
            if (!generatedContent.description || !generatedContent.observation || 
                !generatedContent.remediation || !generatedContent.references) {
                throw new Error('AI response missing required fields');
            }

            // Ensure references is an array
            if (!Array.isArray(generatedContent.references)) {
                generatedContent.references = [];
            }

            // Validate and sanitize CVSS and complexity fields
            let cvssv3 = null;
            let cvssScore = null;
            let remediationComplexity = null;
            let priority = null;

            // Validate CVSS v3 vector string
            if (generatedContent.cvssv3 && typeof generatedContent.cvssv3 === 'string') {
                const cvssPattern = /^CVSS:3\.[01]\/AV:[NALP]\/AC:[LH]\/PR:[NLH]\/UI:[NR]\/S:[UC]\/C:[NLH]\/I:[NLH]\/A:[NLH]$/;
                if (cvssPattern.test(generatedContent.cvssv3)) {
                    cvssv3 = generatedContent.cvssv3;
                }
            }

            // Validate CVSS score
            if (generatedContent.cvssScore && typeof generatedContent.cvssScore === 'number') {
                if (generatedContent.cvssScore >= 0.0 && generatedContent.cvssScore <= 10.0) {
                    cvssScore = Math.round(generatedContent.cvssScore * 10) / 10; // Round to 1 decimal place
                }
            }

            // Validate remediation complexity (1-3)
            if (generatedContent.remediationComplexity && typeof generatedContent.remediationComplexity === 'number') {
                if (generatedContent.remediationComplexity >= 1 && generatedContent.remediationComplexity <= 3) {
                    remediationComplexity = Math.floor(generatedContent.remediationComplexity);
                }
            }

            // Validate priority (1-4)
            if (generatedContent.priority && typeof generatedContent.priority === 'number') {
                if (generatedContent.priority >= 1 && generatedContent.priority <= 4) {
                    priority = Math.floor(generatedContent.priority);
                }
            }

            // Return the generated content for user review
            const responseData = {
                title: title,
                locale: locale,
                description: generatedContent.description,
                observation: generatedContent.observation,
                remediation: generatedContent.remediation,
                references: generatedContent.references,
                cvssv3: cvssv3,
                cvssScore: cvssScore,
                remediationComplexity: remediationComplexity,
                priority: priority
            };

            Response.Ok(res, responseData);

        } catch (error) {
            console.error('OpenAI API Error:', error);
            
            // Handle specific error types
            if (error.code === 'insufficient_quota') {
                Response.BadParameters(res, 'OpenAI API quota exceeded. Please try again later.');
            } else if (error.code === 'rate_limit_exceeded') {
                Response.BadParameters(res, 'OpenAI API rate limit exceeded. Please try again later.');
            } else if (error.message && error.message.includes('API key')) {
                Response.BadParameters(res, 'Invalid OpenAI API key configuration.');
            } else if (error.message && error.message.includes('JSON')) {
                Response.BadParameters(res, 'Failed to parse AI response. Please try again.');
            } else {
                Response.BadParameters(res, 'OpenAI API is currently unavailable. Please try again later.');
            }
        }
    });

    // Update vulnerability
    app.put("/api/vulnerabilities/:vulnerabilityId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        if (!req.body.details) {
            Response.BadParameters(res, 'Required parameters: details.locale, details.title');
            return;
        }
        var index = req.body.details.findIndex(obj => (obj.locale && obj.locale !== '' && obj.title && obj.title !== ''));
        if (index < 0) {
            Response.BadParameters(res, 'Required parameters: details.locale, details.title');
            return;
        }

        var vuln = {}
        if (req.body.cvssv3) vuln.cvssv3 = req.body.cvssv3;
        if (req.body.cvssv4) vuln.cvssv4 = req.body.cvssv4;
        if (req.body.priority) vuln.priority = req.body.priority;
        if (req.body.remediationComplexity) vuln.remediationComplexity = req.body.remediationComplexity;
        vuln.category = req.body.category || null;
        vuln.details = [];
        req.body.details.forEach(d => {
            if (!d.title || !d.locale)
                return
            var details = {};
            if (d.locale) details.locale = d.locale;
            if (d.title) details.title = d.title;
            if (d.vulnType) details.vulnType = d.vulnType;
            if (d.description) details.description = d.description;
            if (d.observation) details.observation = d.observation;
            if (d.remediation) details.remediation = d.remediation;
            if (d.references) details.references = d.references;
            if (d.customFields) details.customFields = d.customFields
            vuln.details.push(details);
        })
        vuln.status = 0;
        
        Vulnerability.update(req.params.vulnerabilityId, vuln)
        .then(msg => {
            if (req.body.status === 2)
                VulnerabilityUpdate.deleteAllByVuln(req.params.vulnerabilityId)
            Response.Ok(res, msg)
        })
        .catch(err => Response.Internal(res, err))
    });

    // Delete vulnerability
    app.delete("/api/vulnerabilities/:vulnerabilityId", acl.hasPermission('vulnerabilities:delete'), function(req, res) {
        Vulnerability.delete(req.params.vulnerabilityId)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Delete all vulnerabilities
    app.delete("/api/vulnerabilities", acl.hasPermission('vulnerabilities:delete-all'), function(req, res) {
        Vulnerability.deleteAll()
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerabilities list by language
    app.get("/api/vulnerabilities/:locale", acl.hasPermission('vulnerabilities:read'), function(req, res) {
        Vulnerability.getAllByLanguage(req.params.locale)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Create or Update vulnerability from finding for validation
    app.post("/api/vulnerabilities/finding/:locale", acl.hasPermission('vulnerability-updates:create'), function(req, res) {
        if (!req.body.title) {
            Response.BadParameters(res, 'Required parameters: title');
            return;
        }
        
        var vuln = {}
        // Required params
        vuln.title = req.body.title;
        vuln.locale = req.params.locale;

        // Optional params
        vuln.cvssv3 = req.body.cvssv3 || null;
        vuln.cvssv4 = req.body.cvssv4 || null;
        vuln.priority = req.body.priority || null;
        vuln.remediationComplexity = req.body.remediationComplexity || null;
        vuln.references = req.body.references || [];
        vuln.vulnType = req.body.vulnType || null;
        vuln.description = req.body.description || null;
        vuln.observation = req.body.observation || null;
        vuln.remediation = req.body.remediation || null;
        vuln.category = req.body.category || null;
        vuln.customFields = req.body.customFields || [];

        VulnerabilityUpdate.create(req.decodedToken.username, vuln)
        .then(msg => {
            if (msg === "Finding created as new Vulnerability")
                Response.Created(res, msg)
            else
                Response.Ok(res, msg)
        })
        .catch(err => Response.Internal(res, err))
    });

    // Get vulnerability updates form vuln id
    app.get("/api/vulnerabilities/updates/:vulnId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        VulnerabilityUpdate.getAllByVuln(req.params.vulnId)
        .then(msg => Response.Ok(res, msg))
        .catch(err => Response.Internal(res, err))
    });

    // Merge vulnerability with locale part of another one
    app.put("/api/vulnerabilities/merge/:vulnId", acl.hasPermission('vulnerabilities:update'), function(req, res) {
        if (!req.body.vulnId || !req.body.locale) {
            Response.BadParameters(res, 'Required parameters: vulnId, locale');
            return;
        }

        Vulnerability.Merge(req.params.vulnId, req.body.vulnId, req.body.locale)
        .then(() => Response.Ok(res, 'Vulnerability merge successfully'))
        .catch(err => Response.Internal(res, err))
    });
}
